---
title: Custom Roles & Permissions
---

import { Step, Steps } from 'fumadocs-ui/components/steps';


<Steps>

### 1) Extend roles

In your database, define the additional roles (e.g., `manager`, `analyst`). With Prisma, you typically store the role string on the membership record. Keep a central enum or constants file in your app to avoid typos.

---

### 2) Define permission mapping

```ts
export const PERMISSIONS: Record<string, string[]> = {
  'org:manage': ['owner', 'admin'],
  'billing:read': ['owner', 'admin', 'manager'],
  'users:invite': ['owner', 'admin', 'manager'],
}
```

---

### 3) Enforce on server

Using `withRole` from `@keyloom/nextjs` to guard actions:

```ts
import { withRole } from '@keyloom/nextjs'
import { PrismaAdapter } from '@keyloom/adapters'
import { PrismaClient } from '@prisma/client'

const db = new PrismaClient()

export async function POST() {
  return withRole(async () => {
    // perform privileged action
    return new Response('ok')
  }, {
    requiredPermission: 'users:invite',
    permMap: PERMISSIONS,
    getUser: async () => ({ id: 'current-user-id' }), // Replace with getUser()
    adapter: PrismaAdapter(db),
  })
}
```

---

### 4) Use in middleware

- Prefer route manifest based protection.
- For legacy `publicRoutes`, avoid whitelisting auth endpoints except UI pages.

---

### 5) Admin UI for assignments

- Use `MembersTable` and related components from `@keyloom/ui/org`.
- Provide a role selector with allowed values.

---

### 6) Troubleshooting

- 403 when role should allow: verify active org cookie and membership record.
- Stale role after change: role is read on request; no cache busting needed, but ensure you write to the correct org.

</Steps>

