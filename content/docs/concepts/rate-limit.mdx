---
title: Rate Limiting
description: Apply simple in-memory or Redis-backed rate limiting to sensitive flows.
---

import { Callout, Steps } from "fumadocs-ui/components";

# Rate Limiting

Keyloom ships two utilities:
- In-memory token bucket: synchronous `rateLimit(key, { capacity, refillPerSec })`
- Async interface: `inMemoryRateLimiter().allow(key, opts)`
- Redis window limiter: `RedisRateLimiter` for production usage

## In-memory example
```ts
import { rateLimit } from "@keyloom/core/guard/rate-limit";

export async function POST(request: Request) {
  const ip = request.headers.get("x-forwarded-for") ?? "unknown";
  if (!rateLimit(`login:${ip}`, { capacity: 5, refillPerSec: 0.1 })) {
    return new Response("Too many attempts", { status: 429 });
  }
  // proceed with login
}
```

## Redis example
```ts
import { RedisRateLimiter } from "@keyloom/core/guard/redis-rate-limiter";

const limiter = new RedisRateLimiter(redis);
if (!(await limiter.allow(`api:${ip}`, { capacity: 100, windowSec: 60 }))) {
  return new Response("Rate limit exceeded", { status: 429 });
}
```

<Callout>
The in-memory limiter resets on process restart and is not distributed. Use the Redis-backed limiter for multi-instance deployments.
</Callout>
