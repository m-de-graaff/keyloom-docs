import { InlineTOC } from "fumadocs-ui/components/inline-toc";

---

title: Adapters
description: Use or implement adapters to connect Keyloom to your database. Prisma/Drizzle and SQL/NoSQL backends supported.

---

# Adapters

Adapters implement a small contract to persist users, sessions, verification tokens, and OAuth accounts. Use a built-in adapter or create your own.

## Use Prisma Adapter

```ts
import { PrismaAdapter } from "@keyloom/adapters";
import { PrismaClient } from "@prisma/client";

const db = new PrismaClient();
const adapter = PrismaAdapter(db);
```

Pass `adapter` into your `keyloom.config.ts` or server builder.

## Adapter Interface

See the Core overview for the full `Adapter` TypeScript interface. Any production adapter must implement:

- Users: create/get/update; unique email
- Accounts: link/get by provider
- Sessions: create/get/delete
- Tokens: create/use verification tokens (single-use, hashed at rest)
- Audit: append audit events

## Testing & Contracts

The repo includes adapter contract tests under `packages/adapters/_contracts`. Use these to validate your custom adapter against the expected behavior (sessions, RBAC, refresh store, etc.).

## Advanced: Other Adapters

Available packages:

- `@keyloom/adapters/prisma`
- `@keyloom/adapters/drizzle`
- `@keyloom/adapters/postgres`
- `@keyloom/adapters/mysql2`
- `@keyloom/adapters/mongo`

Each package exposes a factory similar to `PrismaAdapter(...)`. Consult package READMEs or upcoming per-adapter pages.

## Memory Adapter (Dev/Test)

```ts
import { memoryAdapter } from "@keyloom/core";
const adapter = memoryAdapter();
```

Useful for local prototyping and unit tests. Not for production.

---

## Prerequisites

- Choose a database (Postgres, MySQL, SQLite, MongoDB, etc.)
- Install a compatible adapter package or plan a custom adapter
- Run migrations to create tables for users, accounts, sessions, tokens

## Database schemas

```prisma title="Prisma schema (minimal)"
model User {
  id        String   @id @default(cuid())
  email     String?  @unique
  name      String?
  createdAt DateTime @default(now())
}

model Account {
  id                String @id @default(cuid())
  provider          String
  providerAccountId String
  userId            String
  user              User   @relation(fields: [userId], references: [id])

  @@unique([userId, provider, providerAccountId])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  user      User     @relation(fields: [userId], references: [id])
}

model VerificationToken {
  id         String   @id @default(cuid())
  identifier String
  tokenHash  String
  expiresAt  DateTime
}

model RefreshToken {
  jti       String  @id
  userId    String
  tokenHash String
  expiresAt DateTime
  parentJti String?
  user      User    @relation(fields: [userId], references: [id])
}

model Membership {
  userId String
  orgId  String
  role   String
  user   User   @relation(fields: [userId], references: [id])

  @@id([userId, orgId])
}
```

```ts title="Drizzle (Postgres)"
export const users = pgTable("users", {
  id: text("id").primaryKey(),
  email: text("email").unique(),
  name: text("name"),
});
export const accounts = pgTable("accounts", {
  id: text("id").primaryKey(),
  provider: text("provider").notNull(),
  providerAccountId: text("provider_account_id").notNull(),
  userId: text("user_id").notNull(),
});
export const sessions = pgTable("sessions", {
  id: text("id").primaryKey(),
  userId: text("user_id").notNull(),
  expiresAt: timestamp("expires_at", { withTimezone: true }),
});
export const verificationTokens = pgTable("verification_tokens", {
  id: text("id").primaryKey(),
  identifier: text("identifier").notNull(),
  tokenHash: text("token_hash").notNull(),
  expiresAt: timestamp("expires_at", { withTimezone: true }),
});
export const memberships = pgTable(
  "memberships",
  {
    userId: text("user_id").notNull(),
    orgId: text("org_id").notNull(),
    role: text("role").notNull(),
  },
  (t) => ({ pk: primaryKey({ columns: [t.userId, t.orgId] }) })
);
```

## Adapter API

<InlineTOC
  items={[
    {
      title: "User Management",
      url: "#user-management",
      items: [
        { title: "createUser", url: "#createuser" },
        { title: "getUser", url: "#getuser" },
        { title: "getUserByEmail", url: "#getuserbyemail" },
        { title: "updateUser", url: "#updateuser" },
      ],
    },
    {
      title: "Account Management",
      url: "#account-management",
      items: [
        { title: "linkAccount", url: "#linkaccount" },
        { title: "getAccountByProvider", url: "#getaccountbyprovider" },
      ],
    },
    {
      title: "Session Management",
      url: "#session-management",
      items: [
        { title: "createSession", url: "#createsession" },
        { title: "getSession", url: "#getsession" },
        { title: "deleteSession", url: "#deletesession" },
      ],
    },
    {
      title: "Token Management",
      url: "#token-management",
      items: [
        { title: "createVerificationToken", url: "#createverificationtoken" },
        { title: "useVerificationToken", url: "#useverificationtoken" },
      ],
    },
    {
      title: "Organization & Audit",
      url: "#organization-audit",
      items: [
        { title: "getMembership", url: "#getmembership" },
        { title: "appendAudit", url: "#appendaudit" },
      ],
    },
  ]}
/>

### User Management

#### createUser

- **Params**: `{ email?, name? }`
- **Returns**: `Promise<{ id, email?, name? }>`
- Creates a new user in the database

#### getUser

- **Params**: `string` (user ID)
- **Returns**: `Promise<User | null>`
- Retrieves a user by their ID

#### getUserByEmail

- **Params**: `string` (email address)
- **Returns**: `Promise<User | null>`
- Retrieves a user by their email address

#### updateUser

- **Params**: `string` (user ID), `Partial<User>` (update data)
- **Returns**: `Promise<User>`
- Updates user information

### Account Management

#### linkAccount

- **Params**: `string` (user ID), `Account` (account data)
- **Returns**: `Promise<void>`
- Links an OAuth account to a user

#### getAccountByProvider

- **Params**: `string` (provider), `string` (provider account ID)
- **Returns**: `Promise<Account | null>`
- Retrieves an account by provider and provider account ID

### Session Management

#### createSession

- **Params**: `Session` (session data with userId and expiresAt)
- **Returns**: `Promise<Session>`
- Creates a new user session

#### getSession

- **Params**: `string` (session ID)
- **Returns**: `Promise<Session | null>`
- Retrieves a session by ID

#### deleteSession

- **Params**: `string` (session ID)
- **Returns**: `Promise<void>`
- Deletes a session

### Token Management

#### createVerificationToken

- **Params**: `VerificationToken` (token data with identifier, tokenHash, expiresAt)
- **Returns**: `Promise<void>`
- Creates a verification token

#### useVerificationToken

- **Params**: `string` (identifier), `string` (token hash)
- **Returns**: `Promise<boolean>`
- Uses and removes a verification token, returns success status

### Organization & Audit

#### getMembership

- **Params**: `string` (user ID), `string` (organization ID)
- **Returns**: `Promise<{ role } | null>`
- Retrieves user's membership role in an organization

#### appendAudit

- **Params**: `{ type, userId?, orgId?, meta? }` (audit event)
- **Returns**: `Promise<void>`
- Appends an audit event to the log

> **Note**: Real interfaces include additional fields. See `@keyloom/*adapter*/readme` for exact signatures.

## Runnable: custom adapter skeleton

```ts
export function myAdapter(db: any) {
  return {
    async createUser(data) {
      /* insert */ return { id: "...", ...data };
    },
    async getUser(id) {
      /* select */ return null;
    },
    async getUserByEmail(email) {
      /* select */ return null;
    },
    async updateUser(id, data) {
      /* update */ return { id, ...data };
    },
    async linkAccount(userId, acc) {
      /* upsert */
    },
    async getAccountByProvider(p, pid) {
      /* select */ return null;
    },
    async createSession(s) {
      /* insert */ return s;
    },
    async getSession(id) {
      /* select */ return null;
    },
    async deleteSession(id) {
      /* delete */
    },
    async createVerificationToken(t) {
      /* insert */
    },
    async useVerificationToken(identifier, tokenHash) {
      /* delete where match */ return true;
    },
    async getMembership(userId, orgId) {
      /* select */ return { role: "member" };
    },
    async appendAudit(e) {
      /* insert */
    },
  };
}
```

## Migrations & schema evolution

- Use additive migrations; avoid destructive changes without backfills
- Keep unique indexes on emails and provider accounts
- Add composite PKs where logical IDs exist (e.g., membership)
- For refresh tokens, store only hashes; rotate regularly and prune expired

## Performance considerations

- Add indexes: `accounts(provider, providerAccountId)`, `sessions(userId, expiresAt)`
- Prefer short-lived sessions for high-throughput systems; rely on JWT strategy when possible
- Use connection pooling; for serverless, prefer drivers that support Data Proxy/HTTP
- Batch writes for audit logs or use async outboxes

## Troubleshooting

- Duplicate email errors: ensure `email` is nullable for social logins; enforce uniqueness only when present
- Session not found after sign-in: verify cookie domain/path and session TTL alignment
- RBAC query slow: add index on `memberships(userId, orgId)`

## See also

- Installation: [/docs/getting-started/installation](/docs/getting-started/installation)
- Configuration: [/docs/core/config](/docs/core/config)
- RBAC: [/docs/core/rbac](/docs/core/rbac)

## Next steps

- Pick an adapter package (Prisma/Drizzle) and run migrations
- Implement any custom fields needed and extend the adapter
