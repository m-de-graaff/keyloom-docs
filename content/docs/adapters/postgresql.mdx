---
title: PostgreSQL Adapter
description: Use PostgreSQL with the node-postgres driver to persist Keyloom users, sessions, OAuth accounts, and RBAC.
---

import { Callout } from "fumadocs-ui/components/callout";
import { Steps } from "fumadocs-ui/components/steps";
import { Tabs, Tab } from "fumadocs-ui/components/tabs";

# PostgreSQL Adapter

The PostgreSQL adapter provides direct database access using the popular [node-postgres](https://node-postgres.com/) driver. It offers high performance, advanced PostgreSQL features, and full control over your database connections.

## Features

- **Native PostgreSQL**: Direct access to PostgreSQL features
- **Connection Pooling**: Built-in connection pool management
- **Advanced Types**: Support for PostgreSQL-specific data types
- **RBAC Support**: Organizations, roles, and permissions
- **Audit Logging**: Comprehensive event tracking
- **Custom Queries**: Full SQL control for advanced use cases

<Callout type="info">
This adapter is currently in development. Basic authentication features are available, with RBAC and advanced features coming soon.
</Callout>

## Installation

<Steps>
<Step>

### Install Dependencies

```bash
npm install @keyloom/adapters-postgres pg
npm install -D @types/pg
```

</Step>

<Step>

### Configure Database Connection

```typescript title="lib/db.ts"
import { Pool } from "pg";

export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  // Connection pool settings
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
  // SSL settings for production
  ssl: process.env.NODE_ENV === "production" ? { rejectUnauthorized: false } : false,
});

// Handle pool events
pool.on('connect', (client) => {
  console.log('New PostgreSQL client connected');
});

pool.on('error', (err) => {
  console.error('PostgreSQL pool error:', err);
});
```

</Step>

<Step>

### Configure Keyloom

```typescript title="keyloom.config.ts"
import { defineKeyloom } from "@keyloom/core";
import { postgresAdapter } from "@keyloom/adapters-postgres";
import { pool } from "./lib/db";

export default defineKeyloom({
  baseUrl: process.env.NEXT_PUBLIC_APP_URL!,
  adapter: postgresAdapter({
    pool,
    schema: "keyloom", // Optional: custom schema name
  }),
  session: {
    strategy: "database",
    ttlMinutes: 60,
    rolling: true,
  },
  // ... other config
});
```

</Step>
</Steps>

## Configuration Options

```typescript
interface PostgresAdapterConfig {
  /** PostgreSQL connection pool */
  pool: Pool;
  /** Database schema name (default: 'public') */
  schema?: string;
  /** Table name prefix */
  tablePrefix?: string;
  /** Enable query logging */
  enableLogging?: boolean;
}
```

## Database Schema

The adapter uses a comprehensive PostgreSQL schema optimized for performance:

### Core Tables

```sql
-- Users table
CREATE TABLE keyloom.users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email CITEXT UNIQUE,
  email_verified TIMESTAMPTZ,
  name TEXT,
  image TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Accounts table (OAuth providers)
CREATE TABLE keyloom.accounts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES keyloom.users(id) ON DELETE CASCADE,
  type TEXT NOT NULL,
  provider TEXT NOT NULL,
  provider_account_id TEXT NOT NULL,
  refresh_token TEXT,
  access_token TEXT,
  expires_at BIGINT,
  token_type TEXT,
  scope TEXT,
  id_token TEXT,
  session_state TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(provider, provider_account_id)
);

-- Sessions table
CREATE TABLE keyloom.sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_token TEXT UNIQUE NOT NULL,
  user_id UUID NOT NULL REFERENCES keyloom.users(id) ON DELETE CASCADE,
  expires TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Verification tokens
CREATE TABLE keyloom.verification_tokens (
  identifier TEXT NOT NULL,
  token_hash TEXT NOT NULL,
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  PRIMARY KEY (identifier, token_hash)
);

-- Audit events
CREATE TABLE keyloom.audit_events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type TEXT NOT NULL,
  user_id UUID REFERENCES keyloom.users(id),
  ip INET,
  user_agent TEXT,
  timestamp TIMESTAMPTZ DEFAULT NOW(),
  metadata JSONB
);
```

### Indexes

```sql
-- Performance indexes
CREATE INDEX idx_accounts_user_id ON keyloom.accounts(user_id);
CREATE INDEX idx_sessions_user_id ON keyloom.sessions(user_id);
CREATE INDEX idx_sessions_expires ON keyloom.sessions(expires);
CREATE INDEX idx_verification_tokens_expires ON keyloom.verification_tokens(expires_at);
CREATE INDEX idx_audit_events_user_id ON keyloom.audit_events(user_id);
CREATE INDEX idx_audit_events_timestamp ON keyloom.audit_events(timestamp);
CREATE INDEX idx_audit_events_type ON keyloom.audit_events(type);

-- GIN index for JSONB metadata
CREATE INDEX idx_audit_events_metadata ON keyloom.audit_events USING GIN(metadata);
```

## Database Setup

### Schema Creation

```sql
-- Create dedicated schema
CREATE SCHEMA IF NOT EXISTS keyloom;

-- Grant permissions
GRANT USAGE ON SCHEMA keyloom TO your_app_user;
GRANT CREATE ON SCHEMA keyloom TO your_app_user;
```

### Migration Script

```typescript title="scripts/migrate.ts"
import { pool } from "../lib/db";
import fs from "fs";
import path from "path";

async function runMigrations() {
  const client = await pool.connect();
  
  try {
    // Read and execute migration files
    const migrationDir = path.join(__dirname, "migrations");
    const files = fs.readdirSync(migrationDir).sort();
    
    for (const file of files) {
      if (file.endsWith(".sql")) {
        console.log(`Running migration: ${file}`);
        const sql = fs.readFileSync(path.join(migrationDir, file), "utf8");
        await client.query(sql);
      }
    }
    
    console.log("Migrations completed successfully");
  } finally {
    client.release();
  }
}

runMigrations().catch(console.error);
```

## Advanced Usage

### Custom Schema

```typescript
const adapter = postgresAdapter({
  pool,
  schema: "auth",
  tablePrefix: "app_",
});

// Creates tables: auth.app_users, auth.app_accounts, etc.
```

### Connection Pool Tuning

```typescript title="lib/db.ts"
import { Pool } from "pg";

export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  
  // Pool configuration
  max: 20,                    // Maximum connections
  min: 2,                     // Minimum connections
  idleTimeoutMillis: 30000,   // Close idle connections after 30s
  connectionTimeoutMillis: 2000, // Timeout for new connections
  
  // Query timeout
  query_timeout: 10000,
  
  // Keep alive
  keepAlive: true,
  keepAliveInitialDelayMillis: 10000,
});
```

### Read Replicas

```typescript title="lib/db.ts"
import { Pool } from "pg";

// Write pool (primary)
export const writePool = new Pool({
  connectionString: process.env.DATABASE_WRITE_URL,
  max: 10,
});

// Read pool (replica)
export const readPool = new Pool({
  connectionString: process.env.DATABASE_READ_URL,
  max: 20,
});

// Custom adapter with read/write separation
const adapter = postgresAdapter({
  pool: writePool,
  readPool: readPool, // Optional read replica
});
```

### Custom Queries

```typescript
// Extend adapter with custom analytics
const customAdapter = {
  ...postgresAdapter({ pool }),
  
  async getUserStats(userId: string) {
    const client = await pool.connect();
    try {
      const result = await client.query(`
        SELECT 
          COUNT(*) as total_sessions,
          MAX(created_at) as last_login,
          COUNT(DISTINCT DATE(created_at)) as active_days
        FROM keyloom.sessions 
        WHERE user_id = $1
      `, [userId]);
      
      return result.rows[0];
    } finally {
      client.release();
    }
  }
};
```

## Performance Optimization

### Connection Pooling Best Practices

```typescript
// Environment-specific pool sizes
const poolConfig = {
  development: { max: 5, min: 1 },
  staging: { max: 10, min: 2 },
  production: { max: 20, min: 5 },
};

export const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ...poolConfig[process.env.NODE_ENV as keyof typeof poolConfig],
});
```

### Query Optimization

```sql
-- Analyze query performance
EXPLAIN ANALYZE SELECT * FROM keyloom.users WHERE email = 'user@example.com';

-- Monitor slow queries
SELECT query, mean_time, calls 
FROM pg_stat_statements 
WHERE query LIKE '%keyloom%' 
ORDER BY mean_time DESC;
```

## Troubleshooting

### Common Issues

**Connection Pool Exhaustion**
- Monitor active connections: `SELECT count(*) FROM pg_stat_activity;`
- Adjust pool size based on your application load
- Implement connection retry logic

**Slow Queries**
- Enable query logging: `log_statement = 'all'`
- Use `EXPLAIN ANALYZE` to identify bottlenecks
- Add missing indexes for your query patterns

**SSL Connection Issues**
- Verify SSL configuration in production
- Check certificate validity
- Use `sslmode=require` for secure connections

**Schema Permissions**
- Ensure your database user has necessary permissions
- Grant schema usage: `GRANT USAGE ON SCHEMA keyloom TO app_user;`
- Grant table permissions: `GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA keyloom TO app_user;`

<Callout>
For production deployments, consider using connection poolers like PgBouncer for better resource management.
</Callout>
