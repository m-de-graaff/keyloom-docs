---
title: "@keyloom/adapters API"
description: Complete API reference for database adapters
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs'
import { Callout } from 'fumadocs-ui/components/callout'
import { Steps, Step } from 'fumadocs-ui/components/steps'

# @keyloom/adapters API

Database adapters for Keyloom providing persistent storage for users, sessions, and authentication data.

## Installation

<Tabs items={['npm', 'pnpm', 'yarn']}>
  <Tab value="npm">
    ```bash
    npm install @keyloom/adapters @prisma/client prisma
    ```
  </Tab>
  <Tab value="pnpm">
    ```bash
    pnpm add @keyloom/adapters @prisma/client prisma
    ```
  </Tab>
  <Tab value="yarn">
    ```bash
    yarn add @keyloom/adapters @prisma/client prisma
    ```
  </Tab>
</Tabs>

## Available Adapters

### Prisma Adapter (Recommended)

Production-ready adapter using Prisma ORM for database operations.

**Supported Databases:**
- PostgreSQL (recommended)
- MySQL
- SQLite
- SQL Server
- MongoDB

### Memory Adapter

In-memory adapter for development and testing (included in `@keyloom/core`).

<Callout type="warn">
  Memory adapter stores data in memory and loses all data when the process restarts. Use only for development and testing.
</Callout>

## Prisma Adapter Setup

<Steps>

<Step>

### Install Dependencies

```bash
npm install @keyloom/adapters @prisma/client prisma
```

</Step>

<Step>

### Initialize Prisma

```bash
npx prisma init
```

This creates:
- `prisma/schema.prisma` - Database schema
- `.env` - Environment variables

</Step>

<Step>

### Configure Database

Update your `.env` file:

```bash
# PostgreSQL
DATABASE_URL="postgresql://username:password@localhost:5432/keyloom"

# MySQL
DATABASE_URL="mysql://username:password@localhost:3306/keyloom"

# SQLite
DATABASE_URL="file:./dev.db"
```

</Step>

<Step>

### Add Keyloom Schema

Add the required models to your `prisma/schema.prisma`:

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // or "mysql", "sqlite", etc.
  url      = env("DATABASE_URL")
}

model User {
  id            String    @id @default(cuid())
  email         String?   @unique
  emailVerified DateTime?
  name          String?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts      Account[]
  sessions      Session[]
  credentials   Credential?
  authKeys      AuthKey[]
  auditLogs     AuditLog[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  id         String   @id @default(cuid())
  identifier String
  token      String
  expires    DateTime
  createdAt  DateTime @default(now())
  consumedAt DateTime?

  @@unique([identifier, token])
}

model Credential {
  id     String @id @default(cuid())
  userId String @unique
  hash   String

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AuthKey {
  id        String   @id @default(cuid())
  userId    String
  keyId     String   @unique
  publicKey String
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  type      String
  metadata  Json?
  createdAt DateTime @default(now())

  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)
}
```

</Step>

<Step>

### Generate Client and Migrate

```bash
npx prisma generate
npx prisma db push
```

</Step>

<Step>

### Create Prisma Client

```typescript
// lib/prisma.ts
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;
```

</Step>

</Steps>

## Prisma Adapter Usage

### Basic Configuration

```typescript
// keyloom.config.ts
import { PrismaAdapter } from "@keyloom/adapters/prisma";
import { prisma } from "./lib/prisma";

export default {
  adapter: PrismaAdapter(prisma),
  session: {
    strategy: "database" as const,
    ttlMinutes: 60,
    rolling: true,
  },
  secrets: {
    authSecret: process.env.AUTH_SECRET!,
  },
};
```

### With RBAC Support

For role-based access control, add additional models:

```prisma
model Organization {
  id        String   @id @default(cuid())
  name      String
  slug      String?  @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  members Membership[]
  invites Invite[]
}

model Membership {
  id     String @id @default(cuid())
  userId String
  orgId  String
  role   String
  status String @default("active")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId])
}

model Invite {
  id        String   @id @default(cuid())
  orgId     String
  email     String
  role      String
  tokenHash String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  acceptedAt DateTime?

  org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
}
```

## Memory Adapter Usage

### Basic Configuration

```typescript
// keyloom.config.ts
import { memoryAdapter } from "@keyloom/core";

export default {
  adapter: memoryAdapter(),
  session: {
    strategy: "database" as const,
    ttlMinutes: 60,
    rolling: true,
  },
  secrets: {
    authSecret: process.env.AUTH_SECRET!,
  },
};
```

### With Pre-populated Data

```typescript
import { memoryAdapter } from "@keyloom/core";

// Create adapter with pre-populated store
const adapter = memoryAdapter();

// Pre-populate with test data
await adapter.createUser({
  email: "test@example.com",
  name: "Test User",
});

export default {
  adapter,
  // ... other config
};
```

### Accessing Memory Store

```typescript
import { memoryAdapter } from "@keyloom/core";

const adapter = memoryAdapter();

// Access internal store for debugging
console.log("Users:", adapter.__store.users);
console.log("Sessions:", adapter.__store.sessions);
```

## Adapter Interface

All adapters implement the base `Adapter` interface:

```typescript
interface Adapter {
  // Users
  createUser(data: Partial<User>): Promise<User>;
  getUser(id: ID): Promise<User | null>;
  getUserByEmail(email: string): Promise<User | null>;
  updateUser(id: ID, data: Partial<User>): Promise<User>;

  // Accounts (OAuth)
  linkAccount(acc: Account): Promise<Account>;
  getAccountByProvider(provider: string, providerAccountId: string): Promise<Account | null>;

  // Sessions
  createSession(s: Omit<Session, 'id' | 'createdAt' | 'updatedAt'>): Promise<Session>;
  getSession(id: ID): Promise<Session | null>;
  deleteSession(id: ID): Promise<void>;

  // Tokens (email verify, password reset)
  createVerificationToken(v: Omit<VerificationToken, 'id' | 'createdAt' | 'consumedAt'>): Promise<VerificationToken>;
  useVerificationToken(identifier: string, token: string): Promise<VerificationToken | null>;

  // Audit
  appendAudit(event: AuditEvent): Promise<void>;
}
```

### Extended Adapter Methods

Adapters also provide additional methods for credentials and RBAC:

```typescript
// Credential methods (for password authentication)
createCredential(userId: ID, hash: string): Promise<{ id: ID; userId: ID }>;
getCredentialByUserId(userId: ID): Promise<{ id: ID; userId: ID; hash: string } | null>;
updateCredential(userId: ID, hash: string): Promise<void>;

// RBAC methods (when RBAC is enabled)
createOrganization(data: { name: string; slug?: string | null }): Promise<Organization>;
getOrganization(id: ID): Promise<Organization | null>;
getOrganizationsByUser(userId: ID): Promise<Organization[]>;
addMember(data: { userId: ID; orgId: ID; role: Role }): Promise<Membership>;
updateMember(id: ID, data: Partial<Pick<Membership, 'role' | 'status'>>): Promise<Membership>;
removeMember(id: ID): Promise<void>;
getMembership(userId: ID, orgId: ID): Promise<Membership | null>;
listMembers(orgId: ID): Promise<(Membership & { userEmail?: string | null })[]>;
```

## Creating Custom Adapters

You can create custom adapters for other databases or storage systems:

```typescript
import type { Adapter, User, Session, Account } from "@keyloom/core";

class CustomAdapter implements Adapter {
  constructor(private db: YourDatabase) {}

  async createUser(data: Partial<User>): Promise<User> {
    // Implement user creation
    const user = await this.db.users.create({
      email: data.email,
      name: data.name,
      // ... other fields
    });
    return user;
  }

  async getUser(id: string): Promise<User | null> {
    // Implement user retrieval
    return await this.db.users.findById(id);
  }

  async getUserByEmail(email: string): Promise<User | null> {
    // Implement user lookup by email
    return await this.db.users.findByEmail(email);
  }

  async updateUser(id: string, data: Partial<User>): Promise<User> {
    // Implement user update
    return await this.db.users.update(id, data);
  }

  // Implement all other required methods...
  async createSession(sessionData: Omit<Session, 'id' | 'createdAt' | 'updatedAt'>): Promise<Session> {
    return await this.db.sessions.create(sessionData);
  }

  async getSession(id: string): Promise<Session | null> {
    return await this.db.sessions.findById(id);
  }

  async deleteSession(id: string): Promise<void> {
    await this.db.sessions.delete(id);
  }

  // ... implement remaining methods
}

// Usage
const adapter = new CustomAdapter(yourDatabase);
```

## Database Schema Requirements

### Core Tables

**Users Table:**
- `id` (string, primary key)
- `email` (string, unique, nullable)
- `emailVerified` (datetime, nullable)
- `name` (string, nullable)
- `image` (string, nullable)
- `createdAt` (datetime)
- `updatedAt` (datetime)

**Sessions Table:**
- `id` (string, primary key)
- `userId` (string, foreign key to users.id)
- `expiresAt` (datetime)
- `createdAt` (datetime)
- `updatedAt` (datetime)

**Accounts Table (OAuth):**
- `id` (string, primary key)
- `userId` (string, foreign key to users.id)
- `type` (string)
- `provider` (string)
- `providerAccountId` (string)
- `refresh_token` (string, nullable)
- `access_token` (string, nullable)
- `expires_at` (integer, nullable)
- `token_type` (string, nullable)
- `scope` (string, nullable)
- `id_token` (string, nullable)
- `session_state` (string, nullable)
- `createdAt` (datetime)
- `updatedAt` (datetime)

### Optional Tables

**Credentials Table (Password Auth):**
- `id` (string, primary key)
- `userId` (string, foreign key to users.id, unique)
- `hash` (string)

**VerificationTokens Table:**
- `id` (string, primary key)
- `identifier` (string)
- `token` (string)
- `expires` (datetime)
- `createdAt` (datetime)
- `consumedAt` (datetime, nullable)

**AuditLog Table:**
- `id` (string, primary key)
- `userId` (string, foreign key to users.id, nullable)
- `type` (string)
- `metadata` (json, nullable)
- `createdAt` (datetime)

## Migration Commands

### Prisma

```bash
# Generate Prisma client
npx prisma generate

# Apply schema changes to database
npx prisma db push

# Create and apply migrations
npx prisma migrate dev --name init

# View your data
npx prisma studio

# Reset database
npx prisma migrate reset
```

### Manual SQL Migrations

For custom adapters, you'll need to create your own migration scripts:

```sql
-- PostgreSQL example
CREATE TABLE users (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE,
  email_verified TIMESTAMP,
  name TEXT,
  image TEXT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE sessions (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id TEXT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);

-- Add indexes for performance
CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_expires_at ON sessions(expires_at);
```

## Error Handling

Adapters should map database errors to Keyloom error codes:

```typescript
import { KeyloomError, ERR } from "@keyloom/core";

try {
  await adapter.createUser({ email: "existing@example.com" });
} catch (error) {
  if (error instanceof KeyloomError) {
    switch (error.code) {
      case ERR.EMAIL_EXISTS:
        console.log("Email already registered");
        break;
      case ERR.USER_NOT_FOUND:
        console.log("User not found");
        break;
    }
  }
}
```

## Performance Considerations

### Database Indexes

Ensure proper indexes for performance:

```sql
-- Essential indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_sessions_user_id ON sessions(user_id);
CREATE INDEX idx_sessions_expires_at ON sessions(expires_at);
CREATE INDEX idx_accounts_provider ON accounts(provider, provider_account_id);
CREATE INDEX idx_verification_tokens_identifier ON verification_tokens(identifier, token);
```

### Connection Pooling

Use connection pooling for production:

```typescript
// Prisma with connection pooling
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL + "?connection_limit=10&pool_timeout=20",
    },
  },
});
```

### Session Cleanup

Implement session cleanup for expired sessions:

```typescript
// Clean up expired sessions
await adapter.deleteExpiredSessions();

// Or with raw SQL
await prisma.$executeRaw`DELETE FROM sessions WHERE expires_at < NOW()`;
```

## Testing Adapters

### Memory Adapter for Tests

```typescript
// test-setup.ts
import { memoryAdapter } from "@keyloom/core";

export function createTestAdapter() {
  return memoryAdapter();
}

// test.spec.ts
import { createTestAdapter } from "./test-setup";

describe("Authentication", () => {
  let adapter;

  beforeEach(() => {
    adapter = createTestAdapter();
  });

  it("should create user", async () => {
    const user = await adapter.createUser({
      email: "test@example.com",
      name: "Test User",
    });
    
    expect(user.email).toBe("test@example.com");
    expect(user.id).toBeDefined();
  });
});
```

### Database Testing

```typescript
// Use test database for integration tests
const testPrisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.TEST_DATABASE_URL,
    },
  },
});

beforeEach(async () => {
  // Clean database before each test
  await testPrisma.session.deleteMany();
  await testPrisma.account.deleteMany();
  await testPrisma.user.deleteMany();
});
```
