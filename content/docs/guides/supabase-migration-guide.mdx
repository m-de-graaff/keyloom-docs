---
title: Migrate from Supabase Auth
description: Step-by-step guide to migrate from Supabase Authentication to Keyloom with user data preservation.
---

import { Steps, Step } from "fumadocs-ui/components/steps";
import { Callout } from "fumadocs-ui/components/callout";
import { Tabs, Tab } from "fumadocs-ui/components/tabs";

# Migrate from Supabase Auth

This guide walks you through migrating from Supabase Authentication to Keyloom while preserving your user data and maintaining authentication functionality.

<Callout type="info">
  Supabase Auth migration is straightforward since both systems use PostgreSQL
  and similar OAuth providers. User data can often be migrated directly.
</Callout>

## Pre-Migration Checklist

Before starting the migration:

- [ ] **Export Supabase data**: Backup users and authentication data
- [ ] **Document auth providers**: List all OAuth providers configured
- [ ] **Review RLS policies**: Note Row Level Security policies for migration
- [ ] **Plan database strategy**: Decide on database migration approach
- [ ] **Test environment**: Set up staging environment for testing

## Migration Overview

The migration process involves:

1. **Setup Keyloom** with equivalent providers
2. **Export user data** from Supabase
3. **Migrate database schema** to Keyloom format
4. **Update application code** to use Keyloom
5. **Migrate RLS policies** to application-level authorization
6. **Test and deploy** the new authentication system

<Steps>
<Step>

### Install and Configure Keyloom

Install Keyloom with similar providers to your Supabase setup:

```bash
npm install @keyloom/core @keyloom/nextjs @keyloom/providers @keyloom/adapters
```

Initialize Keyloom with PostgreSQL (to match Supabase):

```bash
npx keyloom init --session database --adapter postgresql --providers google,github,discord --rbac
```

Configure providers in `keyloom.config.ts`:

```typescript title="keyloom.config.ts"
import { defineKeyloom } from "@keyloom/core";
import { postgresAdapter } from "@keyloom/adapters";
import google from "@keyloom/providers/google";
import github from "@keyloom/providers/github";
import discord from "@keyloom/providers/discord";
import { Pool } from "pg";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

export default defineKeyloom({
  adapter: postgresAdapter({ pool }),
  baseUrl: process.env.NEXT_PUBLIC_APP_URL!,
  session: { strategy: "database" },
  providers: [
    google({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
    github({
      clientId: process.env.GITHUB_CLIENT_ID!,
      clientSecret: process.env.GITHUB_CLIENT_SECRET!,
    }),
    discord({
      clientId: process.env.DISCORD_CLIENT_ID!,
      clientSecret: process.env.DISCORD_CLIENT_SECRET!,
    }),
  ],
});
```

</Step>

<Step>

### Export Data from Supabase

<Tabs>
<Tab value="sql" label="SQL Export">

```sql title="scripts/export-supabase-users.sql"
-- Export users from Supabase auth.users table
SELECT
  id,
  email,
  email_confirmed_at,
  phone,
  phone_confirmed_at,
  raw_app_meta_data,
  raw_user_meta_data,
  created_at,
  updated_at,
  last_sign_in_at,
  aud,
  role
FROM auth.users
WHERE deleted_at IS NULL;

-- Export identities (OAuth connections)
SELECT
  id,
  user_id,
  identity_data,
  provider,
  created_at,
  updated_at
FROM auth.identities;

-- Export sessions if needed
SELECT
  id,
  user_id,
  created_at,
  updated_at,
  factor_id,
  aal,
  not_after
FROM auth.sessions
WHERE NOT (expires_at < NOW());
```

</Tab>

<Tab value="javascript" label="JavaScript Export">

```javascript title="scripts/export-supabase-data.js"
const { createClient } = require("@supabase/supabase-js");
const fs = require("fs");

const supabaseUrl = process.env.SUPABASE_URL;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

const supabase = createClient(supabaseUrl, supabaseServiceKey);

async function exportSupabaseData() {
  try {
    // Export users
    const { data: users, error: usersError } = await supabase
      .from("auth.users")
      .select("*")
      .is("deleted_at", null);

    if (usersError) throw usersError;

    // Export identities
    const { data: identities, error: identitiesError } = await supabase
      .from("auth.identities")
      .select("*");

    if (identitiesError) throw identitiesError;

    // Transform data for Keyloom
    const keyloomUsers = users.map((user) =>
      transformSupabaseUser(user, identities)
    );

    fs.writeFileSync(
      "supabase-users-export.json",
      JSON.stringify(keyloomUsers, null, 2)
    );

    console.log(`Exported ${keyloomUsers.length} users`);
  } catch (error) {
    console.error("Export failed:", error);
  }
}

function transformSupabaseUser(supabaseUser, identities) {
  const userIdentities = identities.filter(
    (i) => i.user_id === supabaseUser.id
  );

  return {
    id: supabaseUser.id,
    email: supabaseUser.email,
    emailVerified: supabaseUser.email_confirmed_at
      ? new Date(supabaseUser.email_confirmed_at)
      : null,
    phone: supabaseUser.phone,
    phoneVerified: supabaseUser.phone_confirmed_at
      ? new Date(supabaseUser.phone_confirmed_at)
      : null,
    name:
      supabaseUser.raw_user_meta_data?.full_name ||
      supabaseUser.raw_user_meta_data?.name,
    image:
      supabaseUser.raw_user_meta_data?.avatar_url ||
      supabaseUser.raw_user_meta_data?.picture,
    createdAt: new Date(supabaseUser.created_at),
    updatedAt: new Date(supabaseUser.updated_at),
    lastSignInAt: supabaseUser.last_sign_in_at
      ? new Date(supabaseUser.last_sign_in_at)
      : null,
    // Map Supabase identities to Keyloom accounts
    accounts: userIdentities.map((identity) => ({
      provider: mapSupabaseProvider(identity.provider),
      providerAccountId:
        identity.identity_data?.sub ||
        identity.identity_data?.user_id ||
        identity.id,
      type: "oauth",
      email: identity.identity_data?.email,
    })),
    // Preserve metadata
    appMetadata: supabaseUser.raw_app_meta_data || {},
    userMetadata: supabaseUser.raw_user_meta_data || {},
    // Check if user has password
    hasPassword: userIdentities.some((i) => i.provider === "email"),
  };
}

function mapSupabaseProvider(supabaseProvider) {
  const providerMap = {
    google: "google",
    github: "github",
    discord: "discord",
    apple: "apple",
    microsoft: "microsoft",
    twitter: "x",
    facebook: "facebook",
    email: "credentials",
  };
  return providerMap[supabaseProvider] || supabaseProvider;
}

exportSupabaseData().catch(console.error);
```

</Tab>
</Tabs>

</Step>

<Step>

### Migrate Database Schema

<Tabs>
<Tab value="same-db" label="Same Database">

If using the same PostgreSQL database:

```sql title="migrations/migrate-supabase-to-keyloom.sql"
-- Create Keyloom tables alongside Supabase auth tables
-- Run: keyloom migrate to create the schema first

-- Migrate users from auth.users to keyloom_users
INSERT INTO keyloom_users (
  id, email, email_verified, name, image, created_at, updated_at
)
SELECT
  id,
  email,
  email_confirmed_at,
  COALESCE(
    raw_user_meta_data->>'full_name',
    raw_user_meta_data->>'name'
  ),
  COALESCE(
    raw_user_meta_data->>'avatar_url',
    raw_user_meta_data->>'picture'
  ),
  created_at,
  updated_at
FROM auth.users
WHERE deleted_at IS NULL
ON CONFLICT (id) DO NOTHING;

-- Migrate OAuth identities to keyloom_accounts
INSERT INTO keyloom_accounts (
  id, user_id, type, provider, provider_account_id, created_at
)
SELECT
  gen_random_uuid(),
  user_id,
  'oauth',
  provider,
  COALESCE(
    identity_data->>'sub',
    identity_data->>'user_id',
    id::text
  ),
  created_at
FROM auth.identities
WHERE provider != 'email'
ON CONFLICT DO NOTHING;

-- Handle email/password users
INSERT INTO keyloom_credentials (
  id, user_id, hashed_password, requires_reset, created_at
)
SELECT
  gen_random_uuid(),
  u.id,
  'SUPABASE_HASH_PLACEHOLDER', -- Supabase hashes can't be migrated
  true, -- Require password reset
  u.created_at
FROM auth.users u
JOIN auth.identities i ON u.id = i.user_id
WHERE i.provider = 'email'
  AND u.deleted_at IS NULL
ON CONFLICT DO NOTHING;
```

</Tab>

<Tab value="new-db" label="New Database">

If using a new database:

```javascript title="scripts/import-to-new-database.js"
const { Pool } = require("pg");
const bcrypt = require("bcryptjs");
const fs = require("fs");

const pool = new Pool({
  connectionString: process.env.NEW_DATABASE_URL,
});

async function importUsers() {
  const users = JSON.parse(
    fs.readFileSync("supabase-users-export.json", "utf8")
  );

  console.log(`Importing ${users.length} users...`);

  for (const user of users) {
    const client = await pool.connect();

    try {
      await client.query("BEGIN");

      // Insert user
      await client.query(
        `
        INSERT INTO keyloom_users (
          id, email, email_verified, name, image, created_at, updated_at
        ) VALUES ($1, $2, $3, $4, $5, $6, $7)
        ON CONFLICT (id) DO NOTHING
      `,
        [
          user.id,
          user.email,
          user.emailVerified,
          user.name,
          user.image,
          user.createdAt,
          user.updatedAt,
        ]
      );

      // Insert OAuth accounts
      for (const account of user.accounts) {
        if (account.provider !== "credentials") {
          await client.query(
            `
            INSERT INTO keyloom_accounts (
              id, user_id, type, provider, provider_account_id, created_at
            ) VALUES (gen_random_uuid(), $1, $2, $3, $4, $5)
          `,
            [
              user.id,
              account.type,
              account.provider,
              account.providerAccountId,
              user.createdAt,
            ]
          );
        }
      }

      // Handle password users
      if (user.hasPassword) {
        await client.query(
          `
          INSERT INTO keyloom_credentials (
            id, user_id, hashed_password, requires_reset, created_at
          ) VALUES (gen_random_uuid(), $1, $2, true, $3)
        `,
          [
            user.id,
            await bcrypt.hash("TEMP_PASSWORD_RESET_REQUIRED", 12),
            user.createdAt,
          ]
        );
      }

      await client.query("COMMIT");
      console.log(`Imported user: ${user.email}`);
    } catch (error) {
      await client.query("ROLLBACK");
      console.error(`Failed to import user ${user.email}:`, error.message);
    } finally {
      client.release();
    }
  }

  console.log("Import completed");
}

importUsers().catch(console.error);
```

</Tab>
</Tabs>

</Step>

<Step>

### Update Application Code

Replace Supabase Auth calls with Keyloom:

<Tabs>
<Tab value="client" label="Client-Side">

```typescript title="Before (Supabase)"
import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

// Sign in with email/password
const signIn = async (email: string, password: string) => {
  const { data, error } = await supabase.auth.signInWithPassword({
    email,
    password,
  });
  return { data, error };
};

// Sign in with OAuth
const signInWithGoogle = async () => {
  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: "google",
  });
  return { data, error };
};

// Get current user
const getUser = async () => {
  const {
    data: { user },
  } = await supabase.auth.getUser();
  return user;
};

// Listen to auth changes
supabase.auth.onAuthStateChange((event, session) => {
  console.log(event, session);
});
```

```typescript title="After (Keyloom)"
import { signIn, signOut, getSession } from "@keyloom/nextjs/client";

// Sign in with email/password
const handleSignIn = async (email: string, password: string) => {
  try {
    const result = await signIn("credentials", { email, password });
    return { data: result, error: null };
  } catch (error) {
    return { data: null, error };
  }
};

// Sign in with OAuth
const signInWithGoogle = async () => {
  try {
    const result = await signIn("google");
    return { data: result, error: null };
  } catch (error) {
    return { data: null, error };
  }
};

// Get current user
const getUser = async () => {
  const session = await getSession();
  return session?.user || null;
};

// Listen to auth changes (custom implementation)
export function useAuthStateChange(callback: (user: any) => void) {
  useEffect(() => {
    const checkAuth = async () => {
      const user = await getUser();
      callback(user);
    };

    checkAuth();

    // Listen for storage changes (sign in/out events)
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === "keyloom.session") {
        checkAuth();
      }
    };

    window.addEventListener("storage", handleStorageChange);
    return () => window.removeEventListener("storage", handleStorageChange);
  }, [callback]);
}
```

</Tab>

<Tab value="server" label="Server-Side">

```typescript title="Before (Supabase)"
import { createServerSupabaseClient } from "@supabase/auth-helpers-nextjs";

export async function getServerSideProps(context) {
  const supabase = createServerSupabaseClient(context);

  const {
    data: { session },
  } = await supabase.auth.getSession();

  if (!session) {
    return {
      redirect: {
        destination: "/login",
        permanent: false,
      },
    };
  }

  return {
    props: {
      user: session.user,
    },
  };
}
```

```typescript title="After (Keyloom)"
import { getSession, guard } from "@keyloom/nextjs";
import config from "@/keyloom.config";

export async function getServerSideProps(context) {
  try {
    await guard({ visibility: "private" }, config, { req: context.req });
    const session = await getSession(config, { req: context.req });

    return {
      props: {
        user: session?.user || null,
      },
    };
  } catch (error) {
    return {
      redirect: {
        destination: "/login",
        permanent: false,
      },
    };
  }
}
```

</Tab>
</Tabs>

</Step>

<Step>

### Migrate Row Level Security (RLS)

Convert Supabase RLS policies to application-level authorization:

<Tabs>
<Tab value="rls" label="Supabase RLS">

```sql title="Supabase RLS Policies"
-- Enable RLS on profiles table
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Users can view their own profile
CREATE POLICY "Users can view own profile" ON profiles
  FOR SELECT USING (auth.uid() = id);

-- Users can update their own profile
CREATE POLICY "Users can update own profile" ON profiles
  FOR UPDATE USING (auth.uid() = id);

-- Admins can view all profiles
CREATE POLICY "Admins can view all profiles" ON profiles
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM user_roles
      WHERE user_id = auth.uid() AND role = 'admin'
    )
  );
```

</Tab>

<Tab value="middleware" label="Keyloom Middleware">

```typescript title="middleware/authorization.ts"
import { getSession } from "@keyloom/nextjs";
import config from "@/keyloom.config";

export async function authorizationMiddleware(req, res, next) {
  const session = await getSession(config, { req });

  if (!session) {
    return res.status(401).json({ error: "Unauthorized" });
  }

  const { method, url } = req;
  const userId = req.params?.userId;

  // Users can access their own profile
  if (url.includes("/profiles/") && userId) {
    if (session.user.id === userId) {
      return next();
    }

    // Check if user is admin
    const isAdmin = await checkUserRole(session.user.id, "admin");
    if (isAdmin) {
      return next();
    }

    return res.status(403).json({ error: "Forbidden" });
  }

  next();
}

async function checkUserRole(userId: string, role: string): Promise<boolean> {
  // Implement role checking logic
  const userRole = await prisma.userRole.findFirst({
    where: {
      userId,
      role: { name: role },
    },
  });

  return !!userRole;
}
```

</Tab>
</Tabs>

</Step>

<Step>

### Handle Password Migration

Supabase password hashes cannot be directly imported:

```javascript title="scripts/handle-password-migration.js"
const nodemailer = require("nodemailer");

async function handlePasswordMigration() {
  // Send password reset emails to all email/password users
  const passwordUsers = await prisma.user.findMany({
    where: {
      credentials: {
        requiresReset: true,
      },
    },
  });

  const transporter = nodemailer.createTransporter({
    // Your email configuration
  });

  for (const user of passwordUsers) {
    if (user.email) {
      await transporter.sendMail({
        from: "noreply@yourapp.com",
        to: user.email,
        subject: "Password Reset Required - System Migration",
        html: `
          <h2>Password Reset Required</h2>
          <p>We've migrated to a new authentication system.</p>
          <p>Please reset your password to continue:</p>
          <a href="${
            process.env.APP_URL
          }/reset-password?token=${generateResetToken(user.id)}">
            Reset Password
          </a>
        `,
      });

      console.log(`Sent password reset to: ${user.email}`);
    }
  }
}

handlePasswordMigration().catch(console.error);
```

</Step>

<Step>

### Test and Deploy

Create comprehensive tests for your migration:

```typescript title="tests/supabase-migration.test.ts"
import { test, expect } from "@playwright/test";

test.describe("Supabase to Keyloom Migration", () => {
  test("OAuth users can sign in", async ({ page }) => {
    await page.goto("/login");

    await page.click('[data-testid="google-signin"]');
    // Test OAuth flow

    await expect(page.locator('[data-testid="user-profile"]')).toBeVisible();
  });

  test("user metadata is preserved", async ({ page }) => {
    await signInAsUser(page, "test@example.com");

    const profile = await page.evaluate(() => {
      return fetch("/api/profile").then((r) => r.json());
    });

    expect(profile.metadata.department).toBe("engineering");
    expect(profile.metadata.level).toBe("senior");
  });

  test("authorization works correctly", async ({ page }) => {
    await signInAsUser(page, "user@example.com");

    // Try to access admin-only resource
    const response = await page.evaluate(() => {
      return fetch("/api/admin/users").then((r) => r.status);
    });

    expect(response).toBe(403); // Forbidden
  });
});
```

</Step>
</Steps>

## Common Migration Challenges

### Real-time Subscriptions

**Problem**: Supabase provides real-time subscriptions that don't exist in Keyloom.

**Solution**: Implement real-time features using WebSockets or Server-Sent Events:

```typescript
// Replace Supabase real-time with custom implementation
// Before (Supabase)
// supabase
//   .channel('profiles')
//   .on('postgres_changes', { event: '*', schema: 'public', table: 'profiles' }, payload => {
//     console.log('Change received!', payload)
//   })
//   .subscribe()

// After (Custom WebSocket)
const ws = new WebSocket("ws://localhost:3001/realtime");

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  if (data.table === "profiles") {
    console.log("Profile updated:", data.payload);
  }
};
```

### Edge Functions

**Problem**: Supabase Edge Functions need to be migrated.

**Solution**: Move to Vercel Edge Functions, Cloudflare Workers, or similar:

```typescript
// Migrate Supabase Edge Function to Vercel Edge Function
export const config = {
  runtime: "edge",
};

export default async function handler(req: Request) {
  const session = await getSession(config, { req });

  if (!session) {
    return new Response("Unauthorized", { status: 401 });
  }

  // Your edge function logic here
  return new Response(JSON.stringify({ success: true }));
}
```

### Storage Integration

**Problem**: Supabase Storage integration needs replacement.

**Solution**: Integrate with alternative storage providers:

```typescript
// Replace Supabase Storage with AWS S3, Cloudflare R2, etc.
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";

const s3Client = new S3Client({ region: "us-east-1" });

export async function uploadFile(file: File, userId: string) {
  const key = `uploads/${userId}/${file.name}`;

  await s3Client.send(
    new PutObjectCommand({
      Bucket: process.env.S3_BUCKET,
      Key: key,
      Body: file,
      ContentType: file.type,
    })
  );

  return `https://${process.env.S3_BUCKET}.s3.amazonaws.com/${key}`;
}
```

## Post-Migration Tasks

After successful migration:

- [ ] **Monitor authentication metrics** for issues
- [ ] **Update documentation** with new authentication flows
- [ ] **Decommission Supabase Auth** after stable period
- [ ] **Optimize database performance** for authentication queries
- [ ] **Set up monitoring** and alerting for the new system

## Cost Comparison

Estimate your savings after migrating from Supabase:

```
Supabase Pricing:
- Free tier: 50,000 monthly active users
- Pro: $25/month + $0.00325 per MAU over 100,000
- Team: $599/month + $0.00325 per MAU over 500,000

Example for 200,000 MAU:
- Supabase Pro: $25 + (100,000 Ã— $0.00325) = $350/month = $4,200/year
- Keyloom: $0/year (hosting costs only)
- Annual Savings: $4,200
```

<Callout type="success">
  Most applications see significant cost reduction when migrating from Supabase
  to Keyloom, especially at scale.
</Callout>
